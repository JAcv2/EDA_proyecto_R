---
title: "EDA Proyecto DataViz"
author: "Edward Morales - Julian Acevedo"
date: "2023-11-10"
output:   
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    theme: "readable" #cosmo - journal
---
```{r setup}
knitr::opts_chunk$set(warning = FALSE)
```

# EDA proyecto

# Descripción de datos

El siguiente set de datos pertenece a una serie de interacciones registradas en un centro de llamadas por día a lo largo del tiempo. Los datos están registrados por fecha identificando si es un día feriado o no y la cantidad de llamadas registrada por día.

Descripción de columnas:
- Fecha: fecha de los registros.
- StateHoliday: indicador de días feriados.
- Real Calls: número de llamadas registrado en el día.


## Carga y visualización de datos

```{r}
library(readr)
df_proyect <- read_delim("C:/BK/Julian Acevedo/WFM_2021-11-08/WFM nov.2021/Analitica/U.NORTE/Vizualizacion datos R y Python/Proyecto/ts_dash.csv", 
    delim = ";", escape_double = FALSE, trim_ws = TRUE)
df_proyect$FECHA <- as.Date(df_proyect$FECHA, format = "%d/%m/%Y")

knitr::kable(head(df_proyect, 10))
```

En la tabla se pueden visualizar la carga de los datos y los primeros 10 registros.

## Descripción de los datos

```{r}
summary(df_proyect)
```

La descripción de los datos muestra que el dataset cuenta con 1367 registros, la variable objetivo 'REAL CALLS' tiene una media de 2215.41.

## Información de los datos

```{r}
str(df_proyect)
```
En la información de los datos descubrimos el tipo de dato date en la columna 'FECHA' y tipo num para las columnas 'StateHoliday' y 'REAL CALLS', en todos sin datos null.


## verificar datos unicos

```{r}
nunique <- sapply(df_proyect, function(x) length(unique(x)))
nunique
```
Al verificar datos únicos encontramos que la columna 'FECHA' tiene 1367 datos únicos por lo tanto no tiene ningún datos repetido, la columna 'StateHoliday' tiene 3 datos únicos y suele ser el identificador del día feriado y la columna 'REALL CALLS' presenta 1039 datos únicos esto quiere decir que se tienen  328 registros donde se repite la cantidad de llamadas reales.


## Visualizacion de los datos

```{r}
library(ggplot2)

ggplot(df_proyect, aes(x = FECHA, y = `REAL CALLS`)) +
  geom_line() + 
  labs(title = 'Serie Temporal de Real Calls', 
       x = 'Fecha', 
       y = 'Número de Llamadas') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1))
```
En este grafico se logra identificar que la serie presenta una tendencia positiva.


## Histograma

```{r}
library(ggplot2)
bins_sturges <- 1 + log2(length(df_proyect$`REAL CALLS`))
ggplot(df_proyect, aes(x = `REAL CALLS`)) +
    geom_histogram(aes(y = ..density..), bins_sturges=bins_sturges, colour = "black", fill = "white") +
    geom_density(alpha = .2, fill = "#FF6666") +
    labs(title = 'Histograma de REAL CALLS', x = 'REAL CALLS', y = 'Frecuencia')

```
Graficando el histograma se puede identificar que los datos presentan una concentración de datos principalmente a la izquierda de la distribución.


## Boxplot

```{r}
library(ggplot2)
ggplot(df_proyect, aes(y = `REAL CALLS`)) +
  geom_boxplot() +
  labs(title = 'Boxplot de REAL CALLS', x = 'REAL CALLS', y = '') +
  theme_minimal()
```

Graficando el boxplot se puede identificar que los datos presentan una concentración de datos principalmente a la izquierda de la distribución.

## Graficas de datos por año, mes y dia

```{r}
dff <- df_proyect
dff$AÑO <- format(dff$FECHA, "%Y")
dff$MES <- format(dff$FECHA, "%B")
dff$DiaSemana <- format(dff$FECHA, "%A")
head(dff)
```
Para graficar el comportamiento de los datos por año, mes y día es necesario crear las columnas 'AÑO', 'MES' y 'DiaSemana' con el objetivo de simplificar los filtros por cada una de las agrupaciones.

```{r}
library(ggplot2)
ggplot(dff, aes(x = as.factor(AÑO), y = `REAL CALLS`)) +
  geom_boxplot() +
  labs(title = 'Boxplot llamadas por Año', x = 'Año', y = 'Valor') +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 00, hjust = 1))  # Rota las etiquetas del eje X
```

En la gráfica por año se observa que a la la medica que aumentan los años la cantidad de llamadas aumenta, lo cual explica gráficamente el comportamiento con tendencia positiva. 

```{r}
library(ggplot2)
dff$MES <- factor(dff$MES, levels = c("enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"))
# Crear el boxplot
ggplot(dff, aes(x = MES, y = `REAL CALLS`)) +
  geom_boxplot() +
  labs(title = 'Boxplot llamadas por Mes', x = 'Mes', y = 'Valor') +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rota las etiquetas del eje X

```
En la gráfica por meses de identifica una gran variabilidad en los datos a lo largo de cada uno de los meses. Meses como diciembre 'Didiciembre' que presentan una menor variabilidad que otros.

```{r}
library(ggplot2)
library(forcats)

# Ordenar los días de la semana
dff$DiaSemana <- factor(dff$DiaSemana, levels = c("lunes", "martes", "miércoles", "jueves", "viernes", "sábado", "domingo"))

# Crear el boxplot
ggplot(dff, aes(x = DiaSemana, y = `REAL CALLS`)) +
  geom_boxplot() +
  labs(title = 'Boxplot llamadas por Día de la Semana', x = 'Día', y = 'Valor') +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rota las etiquetas del eje X

```

En los gráficos anteriores podemos identificar que la serie de tiempo de llamadas ha tenido una tendencia positiva a los largo del tiempo, adicional a esto se identifica visualmente una estacionalidad en el comportamiento de las llamadas a lo largo de los meses y mucho más pronunciada cuando lo vemos por día, se entiende que los lunes es cuando mayor cantidad de llamadas ingresa y va descendiendo hasta el día viernes, los sábados y domingos se tienen registros muy bajos de llamadas.


## Datos faltantes

```{r}
library(mice)
md.pattern(df_proyect, plot = TRUE, rotate.names = TRUE)
```


```{r}
sum(is.na(df_proyect$`REAL CALLS`))
```

El set de datos no tiene datos faltantes. Por lo tanto, no es necesario realizar análisis de datos faltantes.

# 2. Prueba Dickey-Fuller


```{r}
sum(df_proyect$`REAL CALLS`)
```
```{r}
head(df_proyect$`REAL CALLS`)
```
```{r}
tail(df_proyect$`REAL CALLS`)
```

```{r}
library(tseries)

# Realizar la prueba de Dickey-Fuller aumentada
dickey_fuller_result <- adf.test(df_proyect$`REAL CALLS`, k = 90)

# Extracción de los resultados
test_stat <- dickey_fuller_result$statistic
p_value <- dickey_fuller_result$p.value
alpha <- 0.05

cat("Hipótesis:\n")
cat("H0: Serie no estacionaria\n")
cat("H1: Serie estacionaria\n")
cat(sprintf("Estadístico de prueba: %.4f\n", test_stat))
cat(sprintf("p-value: %.4f\n", p_value))
cat(sprintf("Alpha: %f\n", alpha))
if (p_value > alpha) {
  cat("No se rechaza H0, por lo tanto la serie no es estacionaria.\n")
} else {
  cat("Se rechaza H0, por lo tanto la serie es estacionaria.\n")
}

```

# 3. Descomposición

```{r}
#ts_TGLS_2 <- ts(df_TGLS$Close, frequency=365, start=c(2012, 5))
ts_proyect <- ts(df_proyect$`REAL CALLS`,frequency=90)
library(TSstudio)
ts_decompose(ts_proyect)
```


Del gráfico de descomposición podemos concluir lo siguiente:

- Observado: muestra el comportamiento original de la serie.
- Tendencia: muestra la tendencia positiva que presenta la serie a lo largo del tiempo.
- Estacionalidad: muestra los patrones que se repiten en la serie, en este caso el patrón semanal es notorio.
- Residuos: muestran los errores del modelo y en este caso aparentan ser aleatorios y pequeños.


# 4. Transformacion de serie no estacionaria a estacionaria

```{r}
library(forecast)
library(ggplot2)

# Definir una función para crear un gráfico de diferenciación y ACF
plot_diff_acf <- function(data, lag.max, diff.order = 0, title.prefix = "") {
  # Aplicar diferenciación
  data.diff <- diff(data, differences = diff.order)
  
  # Crear gráfico de la serie de tiempo diferenciada
  plot.ts(data.diff, main = paste(title.prefix, "Order Differencing"), ylab = "Value")
  
  # Crear gráfico ACF
  Acf(data.diff, lag.max = lag.max, main = paste(title.prefix, "Order Differencing ACF"))
}

plot.ts(df_proyect$`REAL CALLS`, main = "Original Series", ylab = "Value")
Acf(df_proyect$`REAL CALLS`, lag.max = 90, main = "Real Calls")

for (i in 1:2) {
  plot_diff_acf(df_proyect$`REAL CALLS`, lag.max = 90, diff.order = i, title.prefix = paste(i, "nd"))
}

```

## Primera diferenciación

```{r}
library(tseries)

# Realizar la diferencia de la serie y eliminar valores NA
df_proyect_diff <- na.omit(diff(df_proyect$`REAL CALLS`, differences = 1))

# Realizar la prueba de Dickey-Fuller aumentada en la serie diferenciada
dickey_fuller_result <- adf.test(df_proyect_diff)

# Extracción de los resultados
test_stat <- dickey_fuller_result$statistic
p_value <- dickey_fuller_result$p.value
alpha <- 0.05

cat("Hipotesis:\n")
cat("H0: Serie no estacionaria\n")
cat("H1: Serie estacionaria\n")
cat(sprintf("Estadistico de prueba: %.4f\n", test_stat))
cat(sprintf("p-value: %.4f\n", p_value))
cat(sprintf("Alpha: %f\n", alpha))
if (p_value > alpha) {
  cat("No se rechaza H0, por lo tanto la serie no es estacionaria.\n")
} else {
  cat("Se rechaza H0, por lo tanto la serie es estacionaria.\n")
}

```

Realizando le primera diferenciacion y aplicando nuevamente el test de dicky-fuller concluimos que la serie se puede transformar de no estacionaria a estacionaria aplicando diferenciacion.

